#+title: Emacs Default Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Basic Configuration

** Early-init File

We deactivate the tool bar and the scroll bar and inhibit the loading of  =default.el=.
#+begin_src emacs-lisp :tangle ./early-init.el :mkdirp yes
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setopt inhibit-default-init t
          visible-bell t)
#+end_src

** Use Lexical Bindings

We use lexical binding in this file.

#+begin_src emacs-lisp

;; -*- lexical-binding: t; -*-
;; Note: This file is automatically generated from default.org.  
;; Please do not edit this file directly but init.org instead.

#+end_src


** Set Current Language Environment

#+begin_src emacs-lisp
  (setopt current-language-environment "UTF-8")
#+end_src


** Enable some disabled Commands

Some commands are disabled by default. So we want to enable them here by removing the symbol property =disabled= of the symbols naming the commands.

#+NAME: set-symbol-property
#+begin_src emacs-lisp 
  (dolist (symbol '(dired-find-alternate-file
                    downcase-region
                    eval-expression
                    narrow-to-page
                    narrow-to-region
                    scroll-left
                    upcase-region))
    (put symbol 'disable nil))
#+end_src

** Load Path for Additional Scripts

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "scripts/" "~/.config/emacs/"))
#+end_src

** The Custom File

We want Emacs customizations to be in their own file.

#+begin_src emacs-lisp
  ;;;;* Load Customizations
  (unless (and (boundp 'custom-file)
	       custom-file
	       (file-writable-p custom-file))
    (let ((default-custom-file (expand-file-name "custom.el"
						 (file-name-directory load-file-name))))
      (setq custom-file default-custom-file)))
#+end_src



** Fonts

We use as default and fixed pitch font =Fira Code Retina= (see [[https://github.com/tonsky/FiraCode/wiki/Emacs-instructions][here]]). However the ligatures seem not to work. As variable pitch font we use Fira Sans. The settings are done in the customizings.


** Displaying Line and Column Numbers

We display the line number in the left fringe of the buffer window.
#+begin_src emacs-lisp
  (setopt column-number-mode t
          global-display-line-numbers-mode t)
#+end_src

 However, we disable the feature for following  modes:
 #+NAME: modes-without-linenumbers
 - org-mode
 - dired-mode
 - treemacs-mode
 - term-mode
 - shell-mode
 - ehell-mode

#+NAME: modes-to-hooks
#+begin_src emacs-lisp :var modes=modes-without-linenumbers() :tangle no
  (mapcar (lambda (mode-name)
            (derived-mode-hook-name (intern mode-name)))
          modes)
#+end_src


#+begin_src emacs-lisp :var hooks=modes-to-hooks(modes=modes-without-linenumbers())
  (dolist (hook hooks)
    (add-hook hook (lambda () (display-line-numbers-mode 0))))

  (setopt display-line-numbers-grow-only t
          display-line-numbers-width-start 50
          display-line-numbers-minor-tick 0
          display-line-numbers-major-tick 10)
  (set-face-attribute 'line-number nil
                      :inherit '(shadow default)
                      :foreground "dark slate gray"
                      :height 0.7)
  (set-face-attribute 'line-number-current-line nil
                      :inherit 'line-number
                      :foreground "olive drab")
  (set-face-attribute 'line-number-major-tick nil
                      :inherit 'line-number
                      :foreground "#3f4f0f")
  (set-face-attribute 'line-number-minor-tick nil
                      :inherit 'line-number-major-tick)
#+end_src


** Proxy-connect

Since I don't know how to authenticate Emacs to the proxy of Swiss Life, I use an little =C#= program which listens to the local port =8080= and does the authentication to the proxy.  Here we ensure that the program is running simply by calling the process ~proxy-connect~.

#+begin_src emacs-lisp
  (defvar oa-proxy-connect:*process* nil
    "Contains the process of ch.swisslife.ProxyConnect.")
  (defun oa-proxy-connect:start ()
    "Start ch.swisslife.ProxyConnect and return the process object."
    (interactive)
    (unless (process-live-p oa-proxy-connect:*process*)
      (setq oa-proxy-connect:*process* (start-process "proxy-connect" nil "proxy-connect"))))
  (defun oa-proxy-connect:stop ()
    "Stop ch.swisslife.ProxyConnect and return `true' if a running process has been stopped, `nil' else."
    (interactive)
    (when-let ((livep (process-live-p oa-proxy-connect:*process*)))
      (delete-process oa-proxy-connect:*process*)
      (setq oa-proxy-connect:*process* nil)
      livep))
#+end_src
Proxy-connect listens to the local port 8080.
#+begin_src emacs-lisp
  (setopt url-proxy-services
          '(("no_proxy" . "^\\\\(fi-r-git\\\\|localhost\\\\|10\\\\..*\\\\|192\\\\.168\\\\..*\\\\)")
            ("http" . "localhost:8080")
            ("https" . "localhost:8080")))
#+end_src
Let's start proxy-connect.
#+begin_src emacs-lisp
  (oa-proxy-connect:start)
#+end_src


** Configure the Package System

We set the archives
#+begin_src emacs-lisp
  (require 'package)

  (setopt package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("melpa" . "http://melpa.org/packages/")
            ("org" . "http://orgmode.org/elpa/"))
          package-check-signature nil
          package-selected-packages nil)

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src


** Using =use-package=

First we check if =use-package= needs to be intalled, then we tell emacs to require =use-package=. By setting the customizable variable =use-package-always-ensure= to /true/, we won't need to indicate at each =use-package= macro the =:ensure= option.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setopt use-package-always-ensure t)
#+end_src


* Basic UI

** Some Default Customizations

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (savehist-mode t)
    (recentf-mode t)
    (recentf-save-file "~/.config/emacs/recentf")
    (recentf-exclude '(".*/[.]recentf\\'"))
    (search-whitespace-regexp ".*?")
    (isearch-allow-scroll t)
    (isearch-lazy-count t)
    (show-paren-style 'expression)
    (enable-recursive-minibuffers t)
    (minibuffer-depth-indicate-mode t)
    (mouse-autoselect-window -0.25)
    (focus-follows-mouse 'auto-raise)
    (indent-tabs-mode nil))
#+end_src

** Key Bindings

*** General

#+begin_src emacs-lisp
  (use-package general)
#+end_src

** Completion

*** All-The-Icons

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src


*** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :custom
    (vertico-cycle t)
    (vertico-mode 1))
#+end_src


*** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :custom (marginalia-mode 1))
#+end_src


*** All-The-Icons Completion

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :custom (all-the-icons-completion-mode 1))
#+end_src


*** Orderless

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)    ; I want to be in control!
    (orderless-component-separator 'orderless-escapable-split-on-space)
    (orderless-matching-styles
     '(orderless-literal
       orderless-prefixes
       orderless-initialism
       orderless-regexp
       ;; orderless-flex
       ;; orderless-strict-leading-initialism
       ;; orderless-strict-initialism
       ;; orderless-strict-full-initialism
       ;; orderless-without-literal          ; Recommended for dispatches instead
       ))
    (orderless-style-dispatchers
     '(prot-orderless-literal-dispatcher
       prot-orderless-strict-initialism-dispatcher
       prot-orderless-flex-dispatcher))
    :config
    (load-file (expand-file-name "~/.config/emacs/scripts/orderless-utils.el")))
#+end_src


*** Consult

#+begin_src emacs-lisp
  (use-package consult)
#+end_src


*** Embark

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C-." . embark-act)
           :map minibuffer-local-map
                ("C-c C-c" . embark-collect)
                ("C-c C-e" . embark-export)))

  (use-package embark-consult)
#+end_src


*** Corfu

[[https://github.com/minad/corfu][Corfu]] enhances in-buffer completion with a small completion popup. The current candidates are shown in a popup below or above the point. The candidates can be selected by moving up and down. Corfu is the minimalistic in-buffer completion counterpart of the Vertico minibuffer UI.
#+begin_src emacs-lisp
  (use-package corfu
    :init
    (defun corfu-maybe-enable-in-minibuffer ()
      "Enable Corfu in some minibuffers."
      (when (local-variable-p 'completion-at-point-functions)
        (setq-local corfu-auto t)
        (setq-local corfu-echo-delay nil)
        (corfu-mode 1)))
    :config
    (add-hook 'minibuffer-setup-hook #'corfu-maybe-enable-in-minibuffer)
    (global-corfu-mode)
    (corfu-popupinfo-mode))
#+end_src


** Documentation Tools

*** Which Key

#+begin_src emacs-lisp
(use-package which-key
  :config (which-key-mode)
  :diminish which-key-mode
  :custom (which-key-idle-delay 0.5))
#+end_src


*** Helpful

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src


** Navigation

***  ACE Window

#+begin_src emacs-lisp
  (use-package ace-window
    :bind
    (("C-$" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src


*** Wgrep

#+begin_src emacs-lisp
  (use-package wgrep
    :bind
    (:map grep-mode-map
	  ("e" . wgrep-change-to-wgrep-mode)
	  ("C-x C-q" . wgrep-change-to-wgrep-mode)
	  ("C-c C-c" . wgrep-finish-edit)))
#+end_src


*** Ripgrep-Mode

See the [[https://rgel.readthedocs.io/en/latest/index.html][rg manual]].

#+begin_src emacs-lisp
  (use-package rg)
#+end_src


** Appearance

*** DOOM Modeline

#+begin_src emacs-lisp :tangle no
  (use-package doom-modeline
    :config (doom-modeline-mode 1)
    :custom (doom-modeline-height 12))
#+end_src


*** DOOM Themes

#+begin_src emacs-lisp :tangle no
  (use-package doom-themes)
#+end_src



** Editing

*** Multiple-Cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors)
#+end_src


*** IEdit

#+begin_src emacs-lisp
  (use-package iedit
    :config
    (defun iedit-dwim (arg)
      "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
      (interactive "P")
      (if arg
	  (iedit-mode)
	(save-excursion
	  (save-restriction
	    (widen)
	    ;; this function determines the scope of `iedit-start'.
	    (if iedit-mode
		(iedit-done)
	      ;; `current-word' can of course be replaced by other
	      ;; functions.
	      (narrow-to-defun)
	      (iedit-start (current-word) (point-min) (point-max)))))))
    :bind
    (( "C-;" . iedit-dwim)))
#+end_src


* Version Control

** Magit

[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp
  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

*** TODO Forge

NOTE: Make sure to configure a GitHub token before using this package!
- https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
- https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started

#+begin_src emacs-lisp :tangle no
  (use-package forge)
#+end_src


*** Magit Filenotify

Minor mode using emacs' =file-notify= for refreshing =magit='s status buffer at changes in the working directory.  To activate the feature, call =magit-filenotify= in the status buffer.

#+begin_src emacs-lisp
  (use-package magit-filenotify)
#+end_src

*** Git Timemachine

Visit a git-controlled file and issue `M-x git-timemachine` (or bind it to a keybinding of your choice).  If you just need to toggle the time machine you can use `M-x git-timemachine-toggle`.

Use the following keys to navigate historic version of the file
- =p= Visit previous historic version
- =n= Visit next historic version
- =w= Copy the abbreviated hash of the current historic version
- =W= Copy the full hash of the current historic version
- =g= Goto nth revision
- =t= Goto revision by selected commit message
- =q= Exit the time machine
- =b= Run =magit-blame= on the currently visited revision (if magit available)
- =c= Show current commit using magit (if magit available)

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

*** Git Modes Package

This packages provides the major modes =git-attributes-mode=, =git-config-mode= and =git-ignore-mode= for editing corresponding files.
#+begin_src emacs-lisp
  (use-package git-modes)
#+end_src

*** Git Gutter

#+begin_src emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :config
    (setq git-gutter:update-interval 0.02))

  (use-package git-gutter-fringe
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src


** Swagg

We use the package [[https://github.com/isamert/swagg.el][swagg]] for fetching the Swagger API of Gitea.

#+begin_src emacs-lisp :tangle no
  (use-package swagg
    :custom
    swagg-definitions
    '((:name "FI-R-GIT"
             :json "http://fi-r-git/api/swagger"
             :base "http://fi-r-git/swagger.v1.json"
             :header (Authorization "c41ffd470c3211c0bd773d79d1e152273f62f1a1"))
      (:name "GitHub"
             :json "https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json"
             :base "https://api.github.com")
      (:name "GitLab"
             :yaml "https://gitlab.com/gitlab-org/gitlab/-/raw/master/doc/api/openapi/openapi.yaml"
             :base "https://gitlab.com/api")))
#+end_src

* Org Mode

[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

** Basic Config

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.  There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.

We use variable pitch for the text.  

#+begin_src emacs-lisp
  (use-package org
    :pin org

    :hook
    ((org-mode . variable-pitch-mode)
     (org-mode . visual-line-mode)
     (org-mode . org-indent-mode))

    :bind
    ("C-c j" . (lambda () (interactive) (org-capture nil "jj")))

    :config

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    ;;(advice-add 'org-refile :after 'org-save-all-org-buffers)
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    :custom
    (org-ellipsis " ▾")
    (org-hide-emphasis-markers t)

    :custom-face
    (org-block ((t (:inherit fixed-pitch))))
    (org-table ((t (:inherit fixed-pitch))))
    (org-formula ((t (:inherit fixed-pitch))))
    (org-code ((t (:inherit fixed-pitch))))
    (org-table ((t (:inherit fixed-pitch))))
    (org-verbatim ((t (:inherit fixed-pitch))))
    (org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    (org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    (org-checkbox ((t (:inherit fixed-pitch)))))
#+end_src

*** Nicer Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in =org-mode= buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.

#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

*** Center Org Buffers

We use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.  This is really a matter of personal preference so you can remove the block below if you don't like the behavior.

#+begin_src emacs-lisp
  (use-package visual-fill-column
    :after org
    :hook (org-mode . visual-fill-column-mode)
    :custom
    (visual-fill-column-width 100)
    (visual-fill-column-center-text t))
#+end_src

*** Drag-and-Drop images with =org-download=

Utility taken from [[https://github.com/abo-abo/org-download#org-download][here]].

#+begin_src emacs-lisp
  (use-package org-download
    :after (org dired)
    :hook (dired-mode . org-download-enable))
#+end_src


** Configure Babel Languages

To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src


** Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][as it is known by Org Babel]].

#+begin_src emacs-lisp
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (dolist (template '(("sh" . "src shell")
                      ("el" . "src emacs-lisp")
                      ("py" . "src python")))
    (add-to-list 'org-structure-template-alist template))
#+end_src



* Development

** TODO Language Server Protocol

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook
    ((lsp-mode . lsp-headerline-breadcrumb-mode)
     (lsp-mode . (lambda ()
		   (keymap-local-set lsp-keymap-prefix lsp-command-map)))
     (lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-keymap-prefix "C-c l"))
#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :after lsp)
#+end_src

*** TODO Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle no

  (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)

    :config
    ;; Set up Node debugging
    (require 'dap-node)
    (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    ;; Bind `C-c l d` to `dap-hydra` for easy access
    (general-define-key
      :keymaps 'lsp-mode-map
      :prefix lsp-keymap-prefix
      "d" '(dap-hydra t :wk "debugger")))

#+end_src


** Lisp Modes

#+begin_src emacs-lisp

  (defun oa:init-isearch-mode-map ()
    (make-local-variable 'isearch-mode-map)
    (define-key isearch-mode-map "\C-w" 'isearch-yank-symbol-or-char))

  (add-hook 'emacs-lisp-mode-hook 'oa:init-isearch-mode-map)
  (add-hook 'lisp-mode-hook 'oa:init-isearch-mode-map)

#+end_src

*** Macrostep

#+begin_src emacs-lisp
  (use-package macrostep)
#+end_src


*** Parenface 

Use a special face for parentheses.

#+begin_src emacs-lisp
  (use-package paren-face
    :config (global-paren-face-mode)
    :custom-face
    (parenthesis ((t (:foreground "DodgerBlue4")))))
#+end_src

*** Highlight Parentheses

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :config
    (global-highlight-parentheses-mode)
    :hook
    ((emacs-lisp-mode lisp-mode) . highlight-parentheses-mode)
    :custom
    (highlight-parentheses-colors
     '("gold1" "orange1" "IndianRed2" "Purple2" "SteelBlue" "dark slate gray")))
#+end_src

*** Highlight Stages
The =highlight-stages-jit-highlighter= has a bug which manifests itself, among others, in the =org-mode=.  Therefore we don't use the =highlight-stages-global-mode=.  In lisp mode it seems to work well, however...

#+begin_src emacs-lisp
  (use-package highlight-stages
    :hook ((emacs-lisp-mode lisp-mode) . highlight-stages-mode)
    :custom
    (highlight-stages-highlight-real-quote nil)
    :custom-face
    (highlight-stages-negative-level-face ((((background light)) :background "#ffdfdf")
                                           (t :background "442424")))
    (highlight-stages-level-1-face ((((background light)) :background "#ffffbf")
                                    (t :background "#444404")))
    (highlight-stages-level-2-face ((((background light)) :background "#efffcf")
                                    (t :background "#344414")))
    (highlight-stages-level-3-face ((((background light)) :background "#dfffdf")
                                    (t :background "#244424")))
    (highlight-stages-higher-level-face ((((background light)) :background "#cfffef")
                                         (t :background "#144434"))))
#+end_src

*** Paredit

#+begin_src emacs-lisp
(use-package paredit
  :bind (:map paredit-mode-map
              ([return] . paredit-newline)
              ([C-return] . comment-indent-new-line))
  :hook
  ((emacs-lisp-mode lisp-mode) . paredit-mode))
#+end_src


*** Add Hooks

**** For Emacs Lisp Mode

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'lisp-interaction-mode-hook
          (lambda () (local-set-key [C-S-return] 'eval-print-last-sexp)))
#+end_src


**** For Common Lisp Mode

#+begin_src emacs-lisp
  (add-hook 'lisp-mode-hook
            (lambda () (setq lisp-indent-function 'common-lisp-indent-function)))
#+end_src



* Shells in Emacs

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

On our system =cmd.exe= or Powershell use by default the code page 850. So we set this code page as process coding system:

#+begin_src emacs-lisp
  (add-hook (derived-mode-hook-name 'shell-mode)
            (lambda () (set-buffer-process-coding-system 'cp850-dos 'cp850-dos)))
#+end_src


** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp
  (use-package eshell-git-prompt)

  (use-package eshell
    :config
    (eshell-git-prompt-use-theme 'powerline)
    :custom
    (eshell-modules-list
     '(eshell-alias eshell-banner eshell-basic eshell-cmpl eshell-dirs eshell-glob eshell-hist eshell-ls eshell-pred eshell-prompt eshell-rebind eshell-script eshell-smart eshell-term eshell-unix)))
#+end_src


* File Management

** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings

**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!
 
**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** TODO Configuration

#+begin_src emacs-lisp

  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom
    (dired-auto-revert-buffer #'dired-directory-changed-p)
    (dired-make-directory-clickable t)
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    (delete-by-moving-to-trash t)
    (dired-dwim-target t)
    (dired-listing-switches "-AGFhlv --group-directories-first --time-style=iso --dired --color"))

  (use-package dired-single)

  (use-package dired-git-info)

  (use-package dired-k)

  (use-package dired-quick-sort)

  (use-package dired-rainbow)

  (use-package dired-subtree)

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open)

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode))

#+end_src





* Load Custom File

Load custom file.

#+begin_src emacs-lisp
  (load custom-file t t t t)
#+end_src



* Appearance

** Faces

We set some faces.

#+begin_src emacs-lisp
  (use-package emacs
    :custom-face
    (fixed-pitch ((t (:foundry "outline" :family "Fira Code Retina"))))
    (default ((t (:height 130 :weight normal :width normal :slant normal :foundry "outline" :family "Fira Code Retina"))))
    (fixed-pitch-serif ((t (:family "Courier New"))))
    (variable-pitch ((t (:inherit default :height 1.35 :foundry "outline" :family "Fira Sans")))))
#+end_src


** COMMENT Modus Themes

#+begin_src emacs-lisp :tangle no
  (use-package modus-themes
    :ensure nil
    :init (modus-themes-load-themes)
    :config (modus-themes-load-vivendi))
#+end_src






#+Local Variables: 
#+eval: (add-hook 'after-save-hook (lambda () (when (y-or-n-p "Tangle?") (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle)) (when (y-or-n-p "Reload?") (load-file user-init-file)))) nil t) 
#+End:
