#+title: Emacs Default Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Basic Configuration

** Early-init File

We deactivate the tool bar and the scroll bar and inhibit the loading of  =default.el=.
#+begin_src emacs-lisp :tangle ./early-init.el :mkdirp yes
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setopt inhibit-default-init t)
#+end_src

** Use Lexical Bindings

We use lexical binding in this file.

#+begin_src emacs-lisp

;; -*- lexical-binding: t; -*-
;; Note: This file is automatically generated from default.org.  
;; Please do not edit this file directly but default.org instead.

#+end_src


** Inhibit =default.el=

#+begin_src emacs-lisp
  (setq inhibit-default-init t)
#+end_src


** Enable some disabled Commands

Some commands are disabled by default. So we want to enable them here by removing the symbol property =disabled= of the symbols naming the commands.

#+NAME: set-symbol-property
#+begin_src emacs-lisp 
  (dolist (symbol '(dired-find-alternate-file
                    downcase-region
                    eval-expression
                    narrow-to-page
                    narrow-to-region
                    scroll-left
                    upcase-region))
    (put symbol 'disable nil))
#+end_src



** The Custom File

We want Emacs customizations to be in their own file.

#+begin_src emacs-lisp
  ;;;;* Load Customizations
  (progn
    (unless (and (boundp 'custom-file)
                 custom-file
                 (file-writable-p custom-file))
        (let ((default-custom-file (expand-file-name "custom.el"
                                                     (file-name-directory load-file-name))))
          (setq custom-file default-custom-file)))
#+end_src



** Fonts

We use as default and fixed pitch font =Fira Code Retina= (see [[https://github.com/tonsky/FiraCode/wiki/Emacs-instructions][here]]). However the ligatures seem not to work. As variable pitch font we use Fira Sans. The settings are done in the customizings.


** Displaying Line and Column Numbers

We display the line number in the left fringe of the buffer window.
#+begin_src emacs-lisp
  (column-number-mode t)
  (global-display-line-numbers-mode t)
#+end_src

 However, we disable the feature for following  modes:
 #+NAME: modes-without-linenumbers
 - org-mode
 - dired-mode
 - treemacs-mode
 - term-mode
 - shell-mode
 - ehell-mode

#+NAME: modes-to-hooks
#+begin_src emacs-lisp :var modes=modes-without-linenumbers() :tangle no
  (mapcar (lambda (mode-name)
            (derived-mode-hook-name (intern mode-name)))
          modes)
#+end_src


#+begin_src emacs-lisp :var hooks=modes-to-hooks(modes=modes-without-linenumbers())
  (dolist (hook hooks)
    (add-hook hook (lambda () (display-line-numbers-mode 0))))
#+end_src


** Proxy-connect

Since I don't know how to authenticate Emacs to the proxy of Swiss Life, I use an little =C#= program which listens to the local port =8080= and does the authentication to the proxy.  Here we ensure that the program is running simply by calling the process =proxy-connect=.

#+begin_src emacs-lisp
  (defvar oa-proxy-connect:*process* nil
    "Contain the process of ch.swisslife.ProxyConnect")
  (defun oa-proxy-connect:start ()
    "Start ch.swisslife.ProxyConnect and return the process object."
    (interactive)
    (unless (process-live-p oa-proxy-connect:*process*)
      (setq oa-proxy-connect:*process* (start-process "proxy-connect" nil "proxy-connect"))))
  (defun oa-proxy-connect:stop ()
    "Stop ch.swisslife.ProxyConnect and return `true' if a running process has been stopped, `nil' else."
    (interactive)
    (when-let ((livep (process-live-p oa-proxy-connect:*process*)))
      (delete-process oa-proxy-connect:*process*)
      (setq oa-proxy-connect:*process* nil)
      livep))
#+end_src
Proxy-connect listens to the local port 8080.
#+begin_src emacs-lisp
  (setopt url-proxy-services
          '(("no_proxy" . "^\\\\(localhost\\\\|10\\\\..*\\\\|192\\\\.168\\\\..*\\\\)")
            ("http" . "localhost:8080")
            ("https" . "localhost:8080")))
#+end_src
Let's start proxy-connect.
#+begin_src emacs-lisp
  (oa-proxy-connect:start)
#+end_src


** Configure the Package System

We set the archives
#+begin_src emacs-lisp
  (require 'package)

  (setopt package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("melpa" . "http://melpa.org/packages/")
            ("org" . "http://orgmode.org/elpa/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src


** Using =use-package=

First we check if =use-package= needs to be intalled, then we tell emacs to require =use-package=. By setting the customizable variable =use-package-always-ensure= to /true/, we won't need to indicate at each =use-package= macro the =:ensure= option.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setopt use-package-always-ensure t)
#+end_src


* Basic UI

** Key Bindings

*** General

#+begin_src emacs-lisp
  (use-package general)
#+end_src

** Completion

*** All-The-Icons

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src


*** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode 1))
#+end_src


*** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :init (marginalia-mode 1))
#+end_src


*** Consult

#+begin_src emacs-lisp
  (use-package consult)
#+end_src


*** Orderless

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)    ; I want to be in control!
    (completion-category-overrides
     '((file (styles basic-remote ; For `tramp' hostname completion with `vertico'
                     orderless))))
    (orderless-component-separator 'orderless-escapable-split-on-space)
    (orderless-matching-styles
     '(orderless-literal
       orderless-prefixes
       orderless-initialism
       orderless-regexp
       ;; orderless-flex
       ;; orderless-strict-leading-initialism
       ;; orderless-strict-initialism
       ;; orderless-strict-full-initialism
       ;; orderless-without-literal          ; Recommended for dispatches instead
       ))
    (orderless-style-dispatchers
     '(prot-orderless-literal-dispatcher
       prot-orderless-strict-initialism-dispatcher
       prot-orderless-flex-dispatcher))
    :init
    (defun orderless--strict-*-initialism (component &optional anchored)
      "Match a COMPONENT as a strict initialism, optionally ANCHORED.
  The characters in COMPONENT must occur in the candidate in that
  order at the beginning of subsequent words comprised of letters.
  Only non-letters can be in between the words that start with the
  initials.

  If ANCHORED is `start' require that the first initial appear in
  the first word of the candidate.  If ANCHORED is `both' require
  that the first and last initials appear in the first and last
  words of the candidate, respectively."
      (orderless--separated-by
          '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
        (cl-loop for char across component collect `(seq word-start ,char))
        (when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
        (when (eq anchored 'both)
          '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

    (defun orderless-strict-initialism (component)
      "Match a COMPONENT as a strict initialism.
  This means the characters in COMPONENT must occur in the
  candidate in that order at the beginning of subsequent words
  comprised of letters.  Only non-letters can be in between the
  words that start with the initials."
      (orderless--strict-*-initialism component))

    (defun prot-orderless-literal-dispatcher (pattern _index _total)
      "Literal style dispatcher using the equals sign as a suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))

    (defun prot-orderless-strict-initialism-dispatcher (pattern _index _total)
      "Leading initialism  dispatcher using the comma suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "," pattern)
        `(orderless-strict-initialism . ,(substring pattern 0 -1))))

    (defun prot-orderless-flex-dispatcher (pattern _index _total)
      "Flex  dispatcher using the tilde suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "." pattern)
        `(orderless-flex . ,(substring pattern 0 -1)))))
#+end_src


*** All-The-Icons Completion

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src


*** Embark

#+begin_src emacs-lisp
  (use-package embark)

  (use-package embark-consult)
#+end_src


*** Corfu

#+begin_src emacs-lisp
  (use-package corfu)
#+end_src


** Documentation Tools

*** Which Key

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config (setq which-key-idle-delay 0.5))
#+end_src


*** Helpful

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src


** Navigation

***  ACE Window

#+begin_src emacs-lisp
(use-package ace-window
  :bind
  (("C-$" . ace-window)))
#+end_src


*** Wgrep

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src


*** Ripgrep-Mode

See the [[https://rgel.readthedocs.io/en/latest/index.html][rg manual]].

#+begin_src emacs-lisp
  (use-package rg)
#+end_src


** Appearance

*** DOOM Modeline

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 12)))
#+end_src


*** DOOM Themes

#+begin_src emacs-lisp
  (use-package doom-themes)
#+end_src



** Editing

*** Multiple-Cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors)
#+end_src


*** IEdit

#+begin_src emacs-lisp
  (use-package iedit)

  (require 'iedit)

  (defun iedit-dwim (arg)
    "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
    (interactive "P")
    (if arg
        (iedit-mode)
      (save-excursion
        (save-restriction
          (widen)
          ;; this function determines the scope of `iedit-start'.
          (if iedit-mode
              (iedit-done)
            ;; `current-word' can of course be replaced by other
            ;; functions.
            (narrow-to-defun)
            (iedit-start (current-word) (point-min) (point-max)))))))

  (global-set-key (kbd "C-;") 'iedit-dwim)
#+end_src


* Version Control

** Magit

[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  ;; (use-package forge)

#+end_src
*** Magit Filenotify

Minor mode using emacs' =file-notify= for refreshing =magit='s status buffer at changes in the working directory.  To activate the feature, call =magit-filenotify= in the status buffer.

#+begin_src emacs-lisp
  (use-package magit-filenotify)
#+end_src

*** Git Timemachine

Visit a git-controlled file and issue `M-x git-timemachine` (or bind it to a keybinding of your choice). If you just need to toggle the time machine you can use `M-x git-timemachine-toggle`.

Use the following keys to navigate historic version of the file
- =p= Visit previous historic version
- =n= Visit next historic version
- =w= Copy the abbreviated hash of the current historic version
- =W= Copy the full hash of the current historic version
- =g= Goto nth revision
- =t= Goto revision by selected commit message
- =q= Exit the time machine
- =b= Run =magit-blame= on the currently visited revision (if magit available)
- =c= Show current commit using magit (if magit available)

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

*** Git Modes Package

This packages provides the major modes =git-attributes-mode=, =git-config-mode= and =git-ignore-mode= for editing corresponding files.
#+begin_src emacs-lisp
  (use-package git-modes)
#+end_src


* Org Mode

[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

** Better Font Faces

The =oam/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.


#+begin_src emacs-lisp
  (defun oa::org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.3)
                    (org-level-2 . 1.25)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.15)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))
    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch))
#+end_src

** Basic Config

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.  There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.

We use variable pitch for the text.  

#+begin_src emacs-lisp
(defun oa::org-mode-setup ()
  (org-indent-mode)
  (variable-pitch-mode 1)
  (visual-line-mode 1))
#+end_src



#+begin_src emacs-lisp

(use-package org
  :pin org
  :hook (org-mode . oa::org-mode-setup)
  :config
  (setq org-ellipsis " ▾")

  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  (setq org-agenda-files
        '("~/Projects/Code/emacs/OrgFiles/Tasks.org"
          "~/Projects/Code/emacs/OrgFiles/Habits.org"
          "~/Projects/Code/emacs/OrgFiles/Birthdays.org"))

  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60)

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
          (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  (setq org-refile-targets
        '(("Archive.org" :maxlevel . 1)
          ("Tasks.org" :maxlevel . 1)))

  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)

  (setq org-tag-alist
        '((:startgroup)
          ;; Put mutually exclusive tags here
          (:endgroup)
          ("@errand" . ?E)
          ("@home" . ?H)
          ("@work" . ?W)
          ("agenda" . ?a)
          ("planning" . ?p)
          ("publish" . ?P)
          ("batch" . ?b)
          ("note" . ?n)
          ("idea" . ?i)))

  ;; Configure custom agenda views
  (setq org-agenda-custom-commands
        '(("d" "Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

          ("n" "Next Tasks"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))))

          ("W" "Work Tasks" tags-todo "+work-email")

          ;; Low-effort next actions
          ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
           ((org-agenda-overriding-header "Low Effort Tasks")
            (org-agenda-max-todos 20)
            (org-agenda-files org-agenda-files)))

          ("w" "Workflow Status"
           ((todo "WAIT"
                  ((org-agenda-overriding-header "Waiting on External")
                   (org-agenda-files org-agenda-files)))
            (todo "REVIEW"
                  ((org-agenda-overriding-header "In Review")
                   (org-agenda-files org-agenda-files)))
            (todo "PLAN"
                  ((org-agenda-overriding-header "In Planning")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "BACKLOG"
                  ((org-agenda-overriding-header "Project Backlog")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "READY"
                  ((org-agenda-overriding-header "Ready for Work")
                   (org-agenda-files org-agenda-files)))
            (todo "ACTIVE"
                  ((org-agenda-overriding-header "Active Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "COMPLETED"
                  ((org-agenda-overriding-header "Completed Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "CANC"
                  ((org-agenda-overriding-header "Cancelled Projects")
                   (org-agenda-files org-agenda-files)))))))

  (setq org-capture-templates
        `(("t" "Tasks / Projects")
          ("tt" "Task" entry (file+olp "~/Projects/Code/emacs/OrgFiles/Tasks.org" "Inbox")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

          ("j" "Journal Entries")
          ("jj" "Journal" entry
           (file+olp+datetree "~/Projects/Code/emacs/OrgFiles/Journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
           :clock-in :clock-resume
           :empty-lines 1)
          ("jm" "Meeting" entry
           (file+olp+datetree "~/Projects/Code/emacs/OrgFiles/Journal.org")
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :clock-in :clock-resume
           :empty-lines 1)

          ("w" "Workflows")
          ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs/OrgFiles/Journal.org")
           "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

          ("m" "Metrics Capture")
          ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs/OrgFiles/Metrics.org" "Weight")
           "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

  (define-key global-map (kbd "C-c j")
    (lambda () (interactive) (org-capture nil "jj")))

  (oa::org-font-setup))
#+end_src

*** Nicer Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in =org-mode= buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.

#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

*** Center Org Buffers

We use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.  This is really a matter of personal preference so you can remove the block below if you don't like the behavior.

#+begin_src emacs-lisp
(defun oa::org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . oa::org-mode-visual-fill))
#+end_src

*** Drag-and-Drop images with =org-download=

Utility taken from [[https://github.com/abo-abo/org-download#org-download][here]].

#+begin_src emacs-lisp
  (use-package org-download)

  ;; Drag-and-drop to `dired`
  (add-hook 'dired-mode-hook 'org-download-enable)
#+end_src


** Configure Babel Languages

To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src


** Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][as it is known by Org Babel]].

#+begin_src emacs-lisp
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (dolist (template '(("sh" . "src shell")
                      ("el" . "src emacs-lisp")
                      ("py" . "src python")))
    (add-to-list 'org-structure-template-alist template))
#+end_src



* Development

** TODO Language Server Protocol

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . lsp-headerline-breadcrumb-mode)
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :config
    (lsp-enable-which-key-integration t))
#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
#+end_src
**** lsp-treemacs
[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :after lsp)
#+end_src

*** TODO Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle no

  (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)

    :config
    ;; Set up Node debugging
    (require 'dap-node)
    (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    ;; Bind `C-c l d` to `dap-hydra` for easy access
    (general-define-key
      :keymaps 'lsp-mode-map
      :prefix lsp-keymap-prefix
      "d" '(dap-hydra t :wk "debugger")))

#+end_src


** Lisp Modes

#+begin_src emacs-lisp

(defun oa:init-isearch-mode-map ()
  (make-local-variable 'isearch-mode-map)
  (define-key isearch-mode-map "\C-w" 'isearch-yank-symbolic-word-or-char))

(add-hook 'emacs-lisp-mode-hook 'oa:init-isearch-mode-map)
(add-hook 'lisp-mode-hook 'oa:init-isearch-mode-map)

#+end_src

*** Parenface 

Use a special face for parentheses.

#+begin_src emacs-lisp
(use-package paren-face)
#+end_src

*** Highlight Parentheses

#+begin_src emacs-lisp
(use-package highlight-parentheses
  :hook
  ((emacs-lisp-mode lisp-mode) . highlight-parentheses-mode))
#+end_src

*** Paredit

#+begin_src emacs-lisp
(use-package paredit
  :bind (:map paredit-mode-map
              ([return] . paredit-newline)
              ([C-return] . comment-indent-new-line))
  :hook
  ((emacs-lisp-mode lisp-mode) . paredit-mode))
#+end_src
*** Add Hooks

**** For Emacs Lisp Mode

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'lisp-interaction-mode-hook
          (lambda () (local-set-key [C-S-return] 'eval-print-last-sexp)))
#+end_src

**** For Common Lisp Mode

#+begin_src emacs-lisp
  (add-hook 'lisp-mode-hook
            (lambda () (setq lisp-indent-function 'common-lisp-indent-function)))
#+end_src



* Shells in Emacs

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

On our system =cmd.exe= or Powershell use by default the code page 850. So we set this code page as process coding system:

#+begin_src emacs-lisp
  (add-hook (derived-mode-hook-name 'shell-mode)
            (lambda () (set-buffer-process-coding-system 'cp850-dos 'cp850-dos)))
#+end_src


** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp
  (use-package eshell-git-prompt)

  (use-package eshell
    :config
    (eshell-git-prompt-use-theme 'powerline))
#+end_src


* File Management

** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings

**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!
 
**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** TODO Configuration

#+begin_src emacs-lisp

  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom
    (dired-listing-switches "-AGFhlv --group-directories-first --time-style=iso --dired --color"))

  (use-package dired-single)

  (use-package dired-git-info)

  (use-package dired-k)

  (use-package dired-quick-sort)

  (use-package dired-rainbow)

  (use-package dired-subtree)

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open)

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode))

#+end_src





* Load Custom File

Load custom file.

#+begin_src emacs-lisp
  (load custom-file t t t t))
#+end_src


#+Local Variables: 
#+eval: (add-hook 'after-save-hook (lambda () (when (y-or-n-p "Tangle?") (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle)) (when (y-or-n-p "Reload?") (load-file user-init-file)))) nil t) 
#+End:
